diff --git a/src/wayland/mod.rs b/src/wayland/mod.rs
index 73c7b85..e6af503 100644
--- a/src/wayland/mod.rs
+++ b/src/wayland/mod.rs
@@ -231,13 +231,24 @@ impl Session {
 
 impl WaylandHelper {
     pub fn new(conn: wayland_client::Connection) -> Self {
-        // XXX unwrap
-        let (globals, mut event_queue) = registry_queue_init(&conn).unwrap();
+        // Initialize registry and globals
+        let (globals, mut event_queue) = registry_queue_init(&conn)
+            .expect("Failed to initialize registry");
+
         let qh = event_queue.handle();
         let registry_state = RegistryState::new(&globals);
         let screencopy_state = ScreencopyState::new(&globals, &qh);
-        let shm_state = Shm::bind(&globals, &qh).unwrap();
-        let zwp_dmabuf = globals.bind(&qh, 4..=4, sctk::globals::GlobalData).unwrap();
+        let shm_state = Shm::bind(&globals, &qh).expect("Failed to bind SHM");
+
+        // Try to bind DMABUF safely
+        let zwp_dmabuf = globals.list().iter()
+            .find(|g| g.interface == "zwp_linux_dmabuf_v1")
+            .map(|global| {
+                let version = global.version.min(4);
+                globals.bind(&qh, version..=version, sctk::globals::GlobalData)
+                    .expect("Failed to bind DMABUF global")
+            });
+
         let wayland_helper = WaylandHelper {
             inner: Arc::new(WaylandHelperInner {
                 conn,
@@ -248,28 +259,30 @@ impl WaylandHelper {
                 qh: qh.clone(),
                 capturer: screencopy_state.capturer().clone(),
                 wl_shm: shm_state.wl_shm().clone(),
-                dmabuf: Mutex::new(None),
+                dmabuf: Mutex::new(None),  // can store optional DmabufHelper later
                 zwp_dmabuf,
             }),
         };
+
         let dmabuf_state = DmabufState::new(&globals, &qh);
         let _ = dmabuf_state.get_default_feedback(&qh);
+
         let mut data = AppData {
-            // XXX must be before workspace and toplevel_info
             output_state: OutputState::new(&globals, &qh),
             shm_state,
             wayland_helper: wayland_helper.clone(),
             screencopy_state,
             dmabuf_state,
-            // XXX must be before toplevel_info
             workspace_state: WorkspaceState::new(&registry_state, &qh),
             toplevel_info_state: ToplevelInfoState::new(&registry_state, &qh),
             registry_state,
         };
-        event_queue.flush().unwrap();
 
+        // Flush & roundtrip to ensure globals are received
+        event_queue.flush().unwrap();
         event_queue.roundtrip(&mut data).unwrap();
 
+        // Spawn the event loop
         thread::spawn(move || {
             loop {
                 event_queue.blocking_dispatch(&mut data).unwrap();
